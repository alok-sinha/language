Good answers so far, but they don’t tell the full story. Implementing virtual memory is actually a well-orchestrated cooperative dance that involves capabilities of both the hardware and the operating system. It’s actually quite beautiful. I’ll deal with both sides, beginning with the hardware functions.

This is going to get long, because I’m going to attempt to fully answer your question start to finish, so please be patient and read on.

The hardware functions that make virtual memory possible begin with what I’ll call dynamic address transaction, or DAT for short. The hardware has a ‘switch’ (usually a bit in a hardware control mechanism) that determines whether or not the DAT function has been enabled. When DAT is disabled, memory is memory, RAM is RAM, and when the processor accesses a memory address it is referencing the corresponding address in actual real hardware RAM —- no surprises there. However, when DAT (dynamic address translation) is enabled, whenever any hardware instruction begins to reference a memory address, that address is first put through a series of translations (table lookups) to arrive at the effective real RAM address. In order for all this to work correctly, “something” (the operating system) must have first done some initialization to set everything up. In many systems the way this all works is through a multi level table lookup. The first level lookup table must be built by (you guessed it) the operating system. The table itself is a list of real memory addresses, each address being the location of one “secondary” lookup table (each of which must have also been created and initialized by the operating system). The real memory address of the first level lookup table must have been stored into a hardware control register (again by the OS) so that the hardware knows where to find it. Once the tables have been created and the hardware “told” where they are, DAT works like this: Whenever the hardware is about to reference a memory address, it takes the first few bits of that memory address (now correctly called a “virtual address”) and uses it as an index/offset into the first lookup table. From there it obtains the real memory address of the next level table. Then it takes the next few bits of the original “virtual address” and uses them to (again, you guessed it) to index into the second level table to find the real memory address of a “chunk” of hardware RAM. Lastly, it uses the remaining bits of the original “virtual address” as an index/offset into this chunk of RAM in order to arrive at the effective memory location being referenced by whatever machine instruction is in the process of being executed. So, hopefully so far what I’ve explained is the mechanism by which a “virtual address” is translated into a “real address” and used to reference hardware memory. A few things should be evident to you at this point: 1) Any “virtual” address can be made to point to a different “real” memory location simply by changing the contents of the lookup tables. The virtual address itself does not have to change - only the contents of the lookup tables that are used to translate it. 2) This translation process is all done by the machine hardware, but in order to make it work the operating system has to initialize all the tables and tell the machine where to find them. 3) A range of virtual memory addresses that are logically contiguous may in fact reference real storage locations in multiple RAM “chunks” (we’ll call them page frames now) that are anything but contiguous. They may in fact be fragmented all over the hardware. All that matters is that the various translate tables that convert the various virtual addresses into real addresses have been set up correctly.

Ok so far? Let’s keep going all the way to how virtual memory works. Each real memory “chunk” (page frame) has associated with it some indicator bits that reveal something about it. There’s a bit that tells whether or not the page frame has been referenced (looked at) since the last time the “reference bit” was reset (whenever that was) and also whether or not the page frame has been altered since the last time the “change bit” was reset (again whenever that was). There are special instructions that the operating system uses whenever it pleases to reset both of these bits. The OS turns them off, the hardware turns them back on whenever a page frame is either looked at or changed. The OS uses this information when it’s running short of available memory and needs to “steal” some from someone. It prefers to pick page frames that have not been referenced or changed, because that’s less work for the OS. (We’ll come back to this idea later, for now I need to move on.)

The OS always likes to keep an inventory of free/unassigned page frames on hand that it can use for what I’m going to describe next:

So, what happens whenever the hardware goes through the address translation process using the lookup tables, and the information needed to complete the translation is not in the tables - this means that there currently is NO corresponding real memory location that has been assigned to the current virtual address. When this happens, the hardware throws up its hands and quits. It generates an interrupt that says, essentially, “Dude, I can’t deal with this. I’m outta here.” Ah, but what gets control whenever there’s a hardware interrupt? The OS of course. And in this case the OS looks at the interrupt code and can tell that it happened because the hardware wasn’t able to translate an address. So the OS will “save” the execution state of whatever was running when this “page fault” occurred so that it can be retried later, grab one of the page frames from its unused/reserved stash, reset its reference/change bits, go update the lookup tables so that they now will resolve the virtual address to this page frame, and then dispatch “some work” (which may be the process that just page faulted, or some other task that’s running). In either case, the next time the original process that was running when the page fault interrupt happened gets dispatched, it will pick up right where it left off and will be none the wiser than anything unusual happened. Slick huh?

If the system gets REALLY busy with lots of things running, what can happen is that the OS’s “private stash” of free page frames can get depleted more than it likes. When this happens, it will start stealing page frames from other processes that have them allocated. It will first choose frames that have been unreferenced and unchanged (by checking the reference and change bits we talked about earlier), then move on to those that have been referenced but not changed, and finally it will consider page frames that have been both referenced AND changed (usually in order by the respective priority of the processes that own them). When it steals a page frame that has been both referenced and changed, then before it can safely allow that frame to be used by some other process it must first save its contents. This is where the “paging files” on disk come in. These files are where the OS stores the contents of page frames it has “stolen” before it can use them to satisfy demand for memory. Eventually, the process that originally owned that memory and the data in it is going to want it back —- it’s going to generate another “page fault” condition when it does. When that happens, the OS is going to have to 1) allocate a frame from its free stash (and because of the magic of DAT it doesn’t matter what the real RAM address of this frame is because the OS is going to update the DAT lookup tables so that the previous virtual address now points to this new frame), and 2) restore the previous contents of that frame from the copy that it saved on the paging file. Every so often the OS will “tiptoe through real memory” resetting both the reference and change bits on all the page frames whose contents have been saved on the paging file. It does this so that the next time it needs to steal from frames, it can tell which candidates are the “good ones”.

So, you should be getting the idea now that there’s a lot going on behind the scenes to make this all work. The OS has to build and maintain the DAT lookup tables, keep track of how all the page frames are being used (the reference and change bits), satisfy any “page fault” interrupts that happen, and also keep track of all the memory contents that it has temporarily stored in its paging file when it “stole” the page frame that contained it to satisfy some other “page fault”. This is how the cooperative dance between hardware and software is accomplished in order to make the machine appear to have a lot more memory on it than it really does. The amount of “virtual memory” available on the machine is limited only by the number of bits used to form an address, because every virtual address is used as input to the table lookup process (DAT) to translate it into a real address. The more real memory there is on the machine, the more virtual addresses will be “translatable” at one time. Those that aren’t “translatable” will, if referenced, cause a “page fault” interrupt that triggers all the aforementioned activity in the OS to handle it. This works because it takes advantage of the tendency that at any given point in time, a program is only actually using a small fraction of the memory it has “defined” - the rest is sitting there essentially wasted. This mechanism allows the OS and hardware to make efficient use of all the RAM by keeping it busy. It’s a balance. There’s additional overhead involved in keeping all this working, and when things get to the point that all of the processor cycles are being used by the OS to manage all this, there’s not much capacity left to process useful work —— this is what is called “thrashing” - spending all the time performing memory management instead of getting things done. When that happens, it’s time to add more real memory to the machine.

Hope this was helpful.